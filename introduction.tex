% !TEX root = ./thesis.tex
\chapter{Introduction}

\setlength\epigraphwidth{.7\textwidth}
\epigraph{\textit{A graphic is not ``drawn'' once and for all; it is
``constructed'' and reconstructed until it reveals all the relationships
 constituted by the interplay of the data. The best graphic operations are those
 carried out by the decision-maker himself.}} {\textit{Graphics and Graphic
 Information Processing}\\\textsc{Jacques Bertin, 1981}}

Data visualization has gone mainstream. From business intelligence to data
journalism, society has embraced visualization as a medium for recording,
analyzing, and communicating about data. This explosion of use is reflected in
the proliferation of visualization tools, which span the gamut of expressivity.
At one end are chart templates (e.g., Google Fusion Tables, or as found in
spreadsheet packages such as Microsoft Excel). Users can easily generate
recognizable output by choosing from a pre-defined palette of chart types, but
can only customize a handful of properties. At the other end are vector graphics
packages (e.g., Adobe Illustrator), and low-level programming APIs (e.g.,
Processing or OpenGL). Here, users have complete control over the resultant
graphic but the added expressivity trades-off ease-of-use.

Advances in visualization toolkits have popularized \emph{grammar-based}
approaches for visual encodings
\cite{wilkinson:grammar,stolte:polaris,wickham:layered,bostock:protovis,bostock:d3}.
These models are more expressive than chart templates as they decompose the
design space into combinatorial primitives for data transformation and visual
encoding. Moreover, they embody \emph{declarative design}\,---\,the languages
are used to describe \emph{what} the visualization should look like, rather than
\emph{how} it should be rendered. As a result, users are free to focus on visual
encoding and design decisions while the underlying runtime is entirely
responsible for execution concerns and performance
optimization~\cite{heer:protovisjava}.

However, key challenges remain. Interaction is a critical component of effective
visualization, allowing users to interrogate the data and iteratively refine
their mental models~\cite{pike:interactionscience,yi:understanding}. Yet,
existing declarative visualization models provide poor support for interaction
techniques. Users can use simple ``interaction typologies'' (e.g., brushing,
panning, etc.) which offer limited means of customization, or must author
\emph{imperative} event handling callbacks. These callbacks undo the benefits of
declarative design, forcing users to manually maintain
state~\cite{cooper:embedding} or coordinate interleaved execution\,---\,a
complex and error-prone task colloquially referred to ask ``callback
hell''~\cite{edwards:coherent}.

Moreover, most existing declarative models (including
ggplot2~\cite{wickham:layered} and D3~\cite{bostock:d3}) are instantiated via
complex APIs embedded in programming languages. This approach imposes a
non-trivial \emph{articulatory distance}~\cite{hutchins:directmanip} as users
must map their desired \emph{visual} output to \emph{textual} commands\,---\,a
fundamental mismatch in representations.

\section{Thesis Contributions and Outline}

This dissertation is divided into seven chapters, and contributes two new
declarative languages for \emph{interactive} visualization as well as a new
interactive system for visualization design through direct manipulation.

\Cref{sec:related_work} surveys prior work that this dissertation builds on,
including a panoply of visualization toolkits and systems, methods from the
functional programming languages and streaming databases literature, and
generative models of user interfaces.

\Cref{sec:vg:lang} introduces Reactive Vega: a declarative language for
interactive data visualization that models user interaction as \emph{streaming
data}. Alongside established declarative visual encoding primitives, Reactive
Vega introduces event streams and signals, two constructs from Functional
Reactive Programming. Event streams, defined with a novel CSS-inspired selector
syntax, abstract the complexity of capturing and sequencing input events. For
example \texttt{[mousedown, mouseup] > mousemove} defines a stream of drag
events\,---\,a sequence that would previously require three callbacks to modify
external state. Event streams drive signals: dynamic expressions that are
automatically reevaluated when new events fire. Signals parameterize visual
encoding primitives, thereby endowing them with reactive semantics\,---\,when a
new event fires, it is propagated to corresponding signals; dependent visual
encodings are automatically reevaluated and the visualization is automatically
re-rendered. Additional primitives allow interaction techniques to be
generalized and reused across distinct visualizations. This chapter further
demonstrates that Reactive Vega is suitably expressive to cover taxonomies of
interaction techniques for data visualizations.

\Cref{sec:vg:arch} studies the implications of declarative interaction design on
the architecture of visualization systems. The Reactive Vega architecture adapts
and extends techniques from streaming database systems. In particular, an input
declarative specification (expressed as JavaScript Object Notation) is parsed to
construct a dataflow graph. Dataflow operators perform computations on
\emph{changesets} of tuples or scene graph elements, and are \emph{replayed} if
signal parameter values change. To support data-driven multi-view displays, the
dataflow graph is conditioned on data values. As new tuples are observed, or as
interaction events occur, the graph \emph{dynamically rewrites itself} at
runtime by extending or pruning branches. Performance optimizations are
described and comparative benchmark studies conducted to evaluate Reactive
Vega's performance. These studies find that Reactive Vega meets or exceeds the
performance of D3~\cite{bostock:d3} and the prior Vega system.

\Cref{sec:vega-lite} introduces Vega-Lite: a higher-level grammar of interactive
graphics. Vega-Lite extends a traditional grammar of graphics with a \emph{view
composition algebra} for layered and multi-view displays. A novel \emph{grammar
of interaction} features \emph{selections}: an abstraction that defines input
event processing, points of interest, and a predicate function for inclusion
testing. Selections parameterize visual encodings by serving as input data,
defining scale extents, or by driving conditional logic. Vega-Lite
specifications are concise through ambiguity: lower-level details (e.g., the
particular events that trigger a selection) can be omitted and are filled in by
the Vega-Lite compiler. Moreover, a smaller language surface area makes
higher-level reasoning (such as systematic enumeration of alternative designs)
more tractable. This chapter demonstrates these language properties by
recreating the examples from \Cref{sec:vg:lang}.

\Cref{sec:lyra} introduces Lyra: an interactive environment for visualization
design by direct manipulation. Through drag-and-drop interactions, users bind
data values to mark properties. With a data pipeline interface, users can
visually specify and inspect data transformations and layout algorithms. As a
higher-level graphical interface, Lyra allows users to fluidly move between the
different levels of abstraction. Direct manipulation interactions generate
statements in Vega-Lite, which are compiled, and merged into a backing Reactive
Vega specification; the visual inspectors provide complete control over the
latter. Thus, users can iterate between rapidly creating recognizable output and
making fine-grained customizations. This approach yields a diverse range of
visualizations without writing a single line of code.

Finally, \Cref{sec:conclusion} sketches new research opportunities that Reactive
Vega and Vega-Lite enable. These systems have been released as open-source
projects, and researchers have already begun to use them to power the Voyager
visualization recommendation browser~\cite{voyager,voyager2,compassql}, develop
a model for sequencing visualizations~\cite{kim:graphscape}, and
reverse-engineer visualizations from chart images~\cite{poco:reverse}. Moreover,
the broader adoption both have seen\,---\,Vega is in use on Wikipedia, to embed
interactive visualizations within articles, and Vega-Lite can be used within
Jupyter notebooks\,---\,provide a growing and engaged community of users to
study their use with.

\section{Prior Publications and Authorship}

Although I am the principal author for the research detailed in this
dissertation, it is also the product of several years of collaboration with my
primary advisor, Jeffrey Heer, and my colleagues at the University of Washington
Interactive Data Lab. The design of the Reactive Vega language, described in
\Cref{sec:vg:lang}, previously appeared at ACM UIST
2014~\cite{satyanarayan:declarative} with Kanit ``Ham'' Wongsuphasawat
contributing a prototype implementation of the reactive extensions against the
existing Vega codebase. The Reactive Vega architecture (\Cref{sec:vg:arch}) was
published at IEEE VIS 2015~\cite{reactive-vega-arch}, with Ryan Russell and Jane
Hoffswell contributing example visualizations and designing the figures.
Vega-Lite (\Cref{sec:vega-lite}) is joint work with Dominik Moritz and Kanit
``Ham'' Wongsuphasawat. It was published at IEEE VIS 2016~\cite{vega-lite} and
my colleagues led the design and implementation of Vega-Lite's visual encodings.
Finally, Lyra was previously published at EuroVis 2014~\cite{lyra}. To reflect
the contributions of my collaborators, I will use the first-person plural (we)
in these chapters.